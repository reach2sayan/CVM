#!/usr/bin/env python3
"""
Code Created By Sayan Samanta and Axel Van de Walle
"""

import argparse
import os
from pathlib import Path
from typing import Final
import sys
import warnings
import json
import subprocess
import numpy as np
import optimiser as opt
from constraints import Constraints
from bounds import CorrBounds
from energyfunctions import H, H_jacobian, F, F_jacobian, F_hessian
from fit_eci import fit_eci_scipy, fit_eci_lsfit
from clusterdata import ClusterInfo
from logger import Logger
from create_cvm_structures import create_structure

def custom_linspace(start, stop, step=1):
    """
    Like np.linspace but uses step instead of num
    This is inclusive to stop, so if start=1, stop=3, step=0.5
    Output is: array([1., 1.5, 2., 2.5, 3.])
    """

    return np.linspace(start, stop, int((stop - start) / step + 1))


if __name__ == '__main__':

    np.set_printoptions(suppress=True, precision=4)

    structure = os.getcwd()
    path = Path(structure)
    phase = str(path.parent.absolute())

    parser = argparse.ArgumentParser(description='CVM SRO Error Correction Code by Sayan Samanta and Axel van de Walle',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                     )
    clus_fit_params = parser.add_argument_group(
        "Parameters related to cluster fitting")
    opt_params = parser.add_argument_group("Optimisation Parameters")
    sro_fit_params = parser.add_argument_group(
        "Parameters related to fitting SRO as a function of temperature")
    clus_params = parser.add_argument_group("Parameters related to CVM")

    parser.add_argument('--seed',
                        default=42,
                        type=float,
                        help='set numpy random seed (for reproducible experiments)'
                       )
    clus_fit_params.add_argument('--clusters_fit',
                                 default='clusters_fit.out',
                                 help="contain the cluster description for fitting the ECIs ",
                                 )
    clus_fit_params.add_argument('--reference_structures', '-ref',
                                 default='references.in',
                                 help="contains the names of the reference structures used to fit ECI",
                                 )
    clus_fit_params.add_argument('--maximal_clusters', '-maxclus',
                                 default='maxclus.in',
                                 help="constains he name of the maximal cluster file",
                                 )
    clus_fit_params.add_argument('--skip_eci_fitting',
                                 action='store_true',
                                 default=False,
                                 help="Skips the ECI fitting step.",
                                 )
    clus_fit_params.add_argument('--make_substructures_only',
                                 action='store_true',
                                 default=False,
                                 help="Reads cluster description for fitting to create permuted structures and exists",
                                )

    clus_params.add_argument('--eci',
                             default='eci.out',
                             help="file containing ECI's ",
                             )
    clus_params.add_argument('--vmat',
                             default='vmat.out',
                             help="file containing the vmatrix ",
                             )
    clus_params.add_argument('--clusters',
                             default='clusters.out',
                             help="file contain the maximal cluster description ",
                             )
    clus_params.add_argument('--kb',
                             default='configkb.out',
                             help="file containing the kikuchi-barker coefficients ",
                             )
    clus_params.add_argument('--configcoef',
                             default='configmult.out',
                             help="file containing coefficient for each subcluster ",
                             )
    clus_params.add_argument('--config',
                             default='config.out',
                             help="file containing subcluster descriptions ",
                             )
    clus_params.add_argument('--lat', '-l',
                             default='lat.in',
                             help="contains the lattice description of the phase "
                             )

    sro_fit_params.add_argument('--Tmin',
                                default=100,
                                type=int,
                                help="Minimum T at which the SRO correction is to be made "
                                )
    sro_fit_params.add_argument('--Tmax',
                                default=2000,
                                type=int,
                                help="Maximum T at which the SRO correction is to be made "
                                )
    sro_fit_params.add_argument('--Tstep',
                                default=100,
                                type=int,
                                help="Temperature increment steps in which the SRO correction is to be evaluated "
                                )

    opt_params.add_argument('--no_constraint',
                            action='store_true',
                            default=False,
                            help="Flag to disable norm constraint "
                            )
    opt_params.add_argument('--verbose', '-v', action='count', default=0,
                            help="Indicate the verbosity of the fit ",
                            )
    opt_params.add_argument('--maxiter',
                            default=5000,
                            type=int,
                            help="Indicate maximum iterations for the local optimiser ",
                            )
    opt_params.add_argument('--xtol',
                            default=1e-18,
                            type=float,
                            help="Indicate the acceptable difference between two iterations ",
                            )
    opt_params.add_argument('--gtol',
                            default=1e-18,
                            type=float,
                            help="Indicate the acceptable violation of constraints ",
                            )
    opt_params.add_argument('--global_trials',
                            default=50,
                            type=int,
                            help="Indicate the number of initial point iteration for global minima search ",
                            )
    opt_params.add_argument('--show_warning',
                            action='store_true',
                            default=False,
                            help="Enables to show warning ",
                            )
    opt_params.add_argument('--out',
                            default='latest_result.json',
                            help="Indicates the name of the output file ",
                            )
    opt_params.add_argument('--toscreen',
                            action='store_true',
                            default=False,
                            help="Enable logging to screen ",
                            )
    opt_params.add_argument('--log',
                            default='log.out',
                            help="Filename for the log file "
                            )


    args = parser.parse_args()

    sys.stdout = Logger(sys.stdout, args.log, args.toscreen)
    if not args.show_warning:
        warnings.filterwarnings("ignore")

    if args.make_substructures_only:

        clfit = ClusterInfo(clusters_fname=f'{phase}/clusters_fit.out',
                            cluster_only=True
                           )
        print(
            f'Found {clfit.num_clusters} no. of clusters to fit. Creating as many structures...')
        ref_list = open('references.in', 'w')
        ref_list.write(f'{structure}')
        for label in range(clfit.num_clusters*2):
            create_structure(label)
            ref_list.write(f'{structure}/{label}\n')
            ref_list.close()

        sys.exit('Created substructures. Now exiting')

    if args.no_constraint:
        print("Norm Constraint not activated.")
    else:
        print("Norm Constraint activated...")

    # Generate Full Cluster Description
    try:
        clusters_full = subprocess.run(['cvmclus', f'-m={phase}/{args.maximal_clusters}', f'-l={structure}/{args.lat}'],
                                       stdout=subprocess.PIPE,
                                       stderr=subprocess.PIPE,
                                       check=True
                                       )
    except subprocess.SubprocessError as suberr:
        print('Error in generating cluster configuration files for CVM...')
        print(suberr)
        print('Continuing to run. Might work if the required files already exists, maybe created by some previous run of cvmclus')

    print("Cluster Description for CVM:")
    clusters_full = ClusterInfo(clusters_fname=f'{structure}/{args.clusters}',
                                kb_fname=f'{structure}/{args.kb}',
                                configcoef_fname=f'{structure}/{args.configcoef}',
                                config_fname=f'{structure}/{args.config}',
                                vmat_fname=f'{structure}/{args.vmat}',
                                eci_fname=f'{structure}/{args.eci}',
                                cluster_only=False
                                )

    if args.skip_eci_fitting:
        print(f"Skipping ECI fitting step. Using {args.eci} instead")
    else:
        print('\n===================================================\n')
        print(
            'Fitting ECIs.\n')
        energies = {}
        correlations = {}
        try:
            with open(f'{structure}/{args.reference_structures}', 'r') as fref:
                reference_structures = [
                    structure.rstrip() for structure in fref.readlines()]
        except FileNotFoundError as fnotf:
            print(fnotf)
            print(f"{args.reference_structures} not found. Exiting.\n")
            sys.exit(1)

        clusters_fit = ClusterInfo(
            args.clusters_fit, None, None, None, None, None, cluster_only=True)

        for struc in reference_structures:
            try:
                with open(f'{struc}/energy', 'r') as energy_file:
                    e = float(energy_file.readline())

                num_atoms = sum(1 for line in open(f"{struc}/str.in")) - 6
                energies[struc] = e/num_atoms
                with open(f'{struc}/energy_atom', 'w') as feperatom:
                    feperatom.write(str(e/num_atoms))
                corr = subprocess.run(['corrdump', '-c', f'-cf={structure}/{args.clusters_fit}', f'-s={struc}/str.in', f'-l={structure}/{args.lat}'],
                                      stdout=subprocess.PIPE,
                                      stderr=subprocess.PIPE,
                                      check=True
                                      )
                # convert from bytes to string list
                corr = corr.stdout.decode('utf-8').split('\t')[:-1]
                corr = np.array(corr, dtype=np.float32)  # convert to arrays
                assert corr[0] == 1
                correlations[struc] = corr
            except FileNotFoundError as fnotf:
                print(fnotf)
                print(
                    f'Energy of reference structure {struc} not found. Probably some error in DFT calc')

        #eci_tmp = fit_eci_scipy(clusters_fit, correlations, energies, structure)
        eci_tmp = fit_eci_lsfit(clusters_fit, correlations, energies,structure)

        eci_tmp = np.array(
            [*eci_tmp, *np.zeros(clusters_full.num_clusters - clusters_fit.num_clusters)])
        for index, eci in clusters_full.eci.items():
            clusters_full.eci[index] = eci_tmp[index]

        print(f'Fitted ECIs : {clusters_full.eci}')
        print(f'Writing Fitted ECIs to file {args.eci}')
        with open(f'{args.eci}', 'w') as eci_file:
            eci_file.write(f'{clusters_full.num_clusters}\n')
            for _, eci in clusters_full.eci.items():
                eci_file.write(f'{eci}\n')

        print('\n========================================\n')

        for eci, cluster_idx in zip(eci_tmp, clusters_full.clusters.keys()):
            clusters_full.eci[cluster_idx] = eci

    results_sro = []

    with open(f'{structure}/energy_atom', 'r') as f:
        for line in f.readlines():
            F_sqs = float(line)
            print(f"Read in SQS energy\t: {F_sqs:.4f}")

    corr_rnd = subprocess.run(['corrdump', '-c', f'-cf={structure}/{args.clusters}', f'-s={structure}/str.in', f'-l={structure}/{args.lat}', '-rnd'],
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE,
                              check=True
                              )
    # convert from bytes to string list
    corr_rnd = corr_rnd.stdout.decode('utf-8').split('\t')[:-1]
    corr_rnd = np.array(corr_rnd, dtype=np.float32)  # convert to arrays
    assert corr_rnd[0] == 1
    assert clusters_full.check_result_validity(corr_rnd)

    FIXED_CORRS: Final = corr_rnd[clusters_full.single_point_clusters]
    constraints = Constraints(clusters_full)
    bounds = CorrBounds(clusters_full.num_clusters, len(
        clusters_full.single_point_clusters))

    # find ordered correlation
    if not args.no_constraint:
        constraints_ord = constraints.get_constraints_ordered(corr_rnd)
        bounds_ord = bounds.get_sro_bounds(FIXED_CORRS)

        options = {'verbose': args.verbose,
                   'maxiter': args.maxiter,
                   'xtol': args.xtol,
                   'gtol': args.gtol,
                   'initial_constr_penalty': 10
                   }

        print('Calculating Ordered Correlation....')
        result_ord = opt.fit(F=H,
                             cluster_data=clusters_full,
                             temp=0,
                             options=options,
                             jac=H_jacobian,
                             hess=None,
                             NUM_TRIALS=50,
                             bounds=bounds_ord,
                             constraints=constraints_ord,
                             corrs_trial=corr_rnd,
                             approx_deriv=True,
                             display_inter=True,
                             init_random=True,
                             seed=args.seed
                             )

        corr_ord = result_ord.x
        print(f"Ordered correlation\t: {corr_ord}")
        ord2disord_dist = np.linalg.norm(corr_ord - corr_rnd)
        print(
            f"L2 norm between the fully disordered and ordered state:\t {ord2disord_dist}")
        print('\n========================================\n')
        print('Starting T optimisation...\n')
    else:
        print('Starting T optimisation...\n')

    for T in custom_linspace(start=args.Tmin, stop=args.Tmax, step=args.Tstep):

        print(f'\nOptimising at temperature {T} K')

        F_rnd = F(corr_rnd,
                  clusters_full.vmat,
                  clusters_full.kb,
                  clusters_full.clusters,
                  clusters_full.configcoef,
                  T,
                  clusters_full.eci)
        print(f"Disordered CVM energy\t: {F_rnd:.4f}")
        print(f"Disordered Correlations\t: {corr_rnd}")

        if not args.no_constraint:
            constraints_sro = constraints.get_constraints_sro(
                ord2disord_dist, corr_rnd)
        else:
            # similar to ordered since we do not add the norm constraint
            constraints_sro = constraints.get_constraints_ordered(corr_rnd)

        bounds_sro = bounds.get_sro_bounds(FIXED_CORRS)

        options = {'verbose': args.verbose,
                   'maxiter': args.maxiter,
                   'xtol': args.xtol,
                   'gtol': args.gtol,
                   'initial_constr_penalty': 10
                   }

        result = opt.fit(F=F,
                         cluster_data=clusters_full,
                         temp=T,
                         options=options,
                         jac=F_jacobian,
                         hess=F_hessian,
                         NUM_TRIALS=args.global_trials,
                         bounds=bounds_sro,
                         constraints=constraints_sro,
                         corrs_trial=corr_rnd,
                         display_inter=True,
                         seed=args.seed
                         )
        F_cvm = result.fun
        print(f"Optimised CVM energy\t: {F_cvm:.4f}")
        print(f"Optimised Correlation\t: {result.x}")
        print("\n#################################################")
        F_solid_solution = F_sqs + F_cvm - F_rnd
        results_sro.append({'structure': structure.split('/')[-1],
                            'temperature': T,
                            'corrs': list(result.x),
                            'F_sqs': F_sqs,
                            'F_rnd': F_rnd,
                            'F_cvm': F_cvm
                            }
                           )

        corrcols = [f'corr {i}' for i in range(clusters_full.num_clusters)]
        for item in results_sro:
            for idx, corrnum in enumerate(corrcols):
                item[f'{corrnum}'] = item['corrs'][idx]

        with open(args.out, 'w') as fout:
            json.dump(results_sro, fout)
    
    #Now fit the result to a function of T


