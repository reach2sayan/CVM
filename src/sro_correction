#!/usr/bin/env python3
"""
Code Created By Sayan Samanta and Axel Van de Walle
"""

import argparse
import os
from pathlib import Path
import sys
import warnings
import json
import subprocess
from datetime import date

import numpy as np
import scipy as sp

import optimiser as opt
from constraints import Constraints
from bounds import CorrBounds
from energyfunctions import *
from fit_eci import fit_eci_scipy, fit_eci_lsfit, fit_eci_ransac
from clusterdata import ClusterInfo
from logger import Logger
from create_cvm_structures import create_structure
from sro_T_fit import sro_T_fit


if __name__ == '__main__':

    def custom_linspace(start, stop, step=1):
        """
        Like np.linspace but uses step instead of num
        This is inclusive to stop, so if start=1, stop=3, step=0.5
        Output is: array([1., 1.5, 2., 2.5, 3.])
        """

        return np.linspace(start, stop, int((stop - start) / step + 1))

    np.set_printoptions(suppress=True, precision=4)
    date = date.today().strftime('%b-%d')
    structure = os.getcwd()
    path = Path(structure)
    phase = str(path.parent.absolute())

    parser = argparse.ArgumentParser(description='CVM SRO Error Correction Code by Sayan Samanta and Axel van de Walle',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                     )
    clus_fit_params = parser.add_argument_group(
        "Parameters related to cluster fitting")
    opt_params = parser.add_argument_group("Optimisation Parameters")
    sro_fit_params = parser.add_argument_group(
        "Parameters related to fitting SRO as a function of temperature")
    clus_params = parser.add_argument_group("Parameters related to CVM")

    parser.add_argument('--seed',
                        default=42,
                        type=float,
                        help='set numpy random seed (for reproducible experiments)'
                        )
    clus_fit_params.add_argument('--clusters_fit', '-cfit',
                                 default='clusters_fit.out',
                                 help="contain the cluster description for fitting the ECIs ",
                                 )
    clus_fit_params.add_argument('--use_lsfit', '-lsfit',
                                 action='store_true',
                                 default=False,
                                 help="Use ATAT lsfit to fit ECI",
                                )
    clus_fit_params.add_argument('--use_ransac', '-ransac',
                                 action='store_true',
                                 default=True,
                                 help="Use sklearn RANSACRegressor ECI",
                                )
    clus_fit_params.add_argument('--reference_structures', '-ref',
                                 default='references.in',
                                 help="contains the names of the reference structures used to fit ECI",
                                 )
    clus_fit_params.add_argument('--maximal_clusters', '-maxclus',
                                 default='maxclus.in',
                                 help="constains he name of the maximal cluster file",
                                 )
    clus_fit_params.add_argument('--fit_eci_only', '-feo',
                                 action='store_true',
                                 default=False,
                                 help="Flag to only fit ECI and exit.",
                                 )
    clus_fit_params.add_argument('--skip_eci_fitting', '-sef',
                                 action='store_true',
                                 default=False,
                                 help="Skips the ECI fitting step.",
                                 )
    clus_fit_params.add_argument('--make_substructures_only',
                                 action='store_true',
                                 default=False,
                                 help="Reads cluster description for fitting to create permuted structures and exists",
                                 )
    clus_fit_params.add_argument('--percent_shuffle', '-ps',
                                 type=float,
                                 default=0.25,
                                 help="how many times to shuffle labels to create structures for ECI fit",
                                 )
    clus_fit_params.add_argument('--mult_substructures', '-ms',
                                 type=float,
                                 default=2,
                                 help="how many substructures to make as a multiple of number of ECI to fit",
                                 )

    clus_params.add_argument('--eci',
                             default='eci.out',
                             help="file containing ECI's ",
                             )
    clus_params.add_argument('--vmat',
                             default='vmat.out',
                             help="file containing the vmatrix ",
                             )
    clus_params.add_argument('--clusters', '-cl',
                             default='clusters.out',
                             help="file contain the maximal cluster description ",
                             )
    clus_params.add_argument('--clustermult',
                             default='clusmult.out',
                             help="file containing multiplicities for each cluster ",
                            )
    clus_params.add_argument('--kb',
                             default='configkb.out',
                             help="file containing the kikuchi-barker coefficients ",
                             )
    clus_params.add_argument('--configmult',
                             default='configmult.out',
                             help="file containing multiplicities for each configuration ",
                             )
    clus_params.add_argument('--config',
                             default='config.out',
                             help="file containing subcluster descriptions ",
                             )
    clus_params.add_argument('--lat', '-l',
                             default='lat.in',
                             help="contains the lattice description of the phase "
                             )

    sro_fit_params.add_argument('--Tmin',
                                default=100,
                                type=int,
                                help="Minimum T at which the SRO correction is to be made "
                                )
    sro_fit_params.add_argument('--Tmax',
                                default=2000,
                                type=int,
                                help="Maximum T at which the SRO correction is to be made "
                                )
    sro_fit_params.add_argument('--Tstep',
                                default=100,
                                type=int,
                                help="Temperature increment steps in which the SRO correction is to be evaluated "
                                )
    sro_fit_params.add_argument('--degree', '--deg',
                                default='3',
                                type=int,
                                help="Maximum power of the fit ",
                                )
    sro_fit_params.add_argument('--sro_method',
                                default='least-squares',
                                help="method of fitting a function on T to the SRO correction",
                                )
    sro_fit_params.add_argument('--coeff_out',
                                default='sro_coeffs.out',
                                help="filename to store the result of the fit ",
                                )
    sro_fit_params.add_argument('--coeff_in',
                                default='sro_coeffs.in',
                                help="filename to store the initial params of the fit ",
                                )
    sro_fit_params.add_argument('--skip_expo',
                                action='store_true',
                                default=False,
                                help="Flag to skip fitting exponents ",
                                )
    sro_fit_params.add_argument('--skip_sro_fit',
                                action='store_true',
                                default=False,
                                help="Flag to skip fitting SRO correction as a function of T",
                                )
    sro_fit_params.add_argument('--fit_sro_only',
                                action='store_true',
                                default=False,
                                help="Flag to optimisation but only fit SRO correction as a function of",
                                )

    opt_params.add_argument('--no_constraint',
                            action='store_true',
                            default=False,
                            help="Flag to disable norm constraint "
                            )
    opt_params.add_argument('--fit_ordered_only',
                            action='store_true',
                            default=False,
                            help="Flag to find find_ordered state only and exit."
                           )
    opt_params.add_argument('--linprog_method',
                            default='revised simplex',
                            help="Method of linear programming for findiing ordered correlations",
                           )
    opt_params.add_argument('--verbose', '-v', action='count', default=0,
                            help="Indicate the verbosity of the fit ",
                            )
    opt_params.add_argument('--approx_deriv',
                            action='store_true',
                            default=False,
                            help="Flag to enable estimation of derivatives",
                           )
    opt_params.add_argument('--maxiter',
                            default=5000,
                            type=int,
                            help="Indicate maximum iterations for the local optimiser ",
                            )
    opt_params.add_argument('--earlystop',
                            default=25,
                            type=int,
                            help="Number of steps to break out of trials if no new minima has been found.",
                           )
    opt_params.add_argument('--xtol',
                            default=1e-12,
                            type=float,
                            help="Indicate the acceptable difference between two iterations ",
                            )
    opt_params.add_argument('--gtol',
                            default=1e-12,
                            type=float,
                            help="Indicate the acceptable violation of constraints ",
                            )
    opt_params.add_argument('--global_trials',
                            default=50,
                            type=int,
                            help="Indicate the number of initial point iteration for global minima search ",
                            )
    opt_params.add_argument('--show_warning',
                            action='store_true',
                            default=False,
                            help="Enables to show warning ",
                            )
    opt_params.add_argument('--out',
                            default='result.json',
                            help="Indicates the name of the output file ",
                            )
    opt_params.add_argument('--toscreen',
                            action='store_true',
                            default=False,
                            help="Enable logging to screen ",
                            )
    opt_params.add_argument('--log',
                            default='log.out',
                            help="Filename for the log file "
                            )

    args = parser.parse_args()

    if not args.no_constraint:
        args.log = f'{args.log}-cons-{date}'
        args.out = f'{args.out}-cons-{date}'
    else:
        args.log = f'{args.log}-nocons-{date}'
        args.out = f'{args.out}-nocons-{date}'

    sys.stdout = Logger(sys.stdout, args.log, args.toscreen)
    print(f"Phase: {phase.split('/')[-1]}")
    print(f"Structure : {structure.split('/')[-1]}")
    if not args.show_warning:
        warnings.filterwarnings("ignore")

    # This part of the code only makes the subdirectories on which the user to run DFT.
    # To generate data for ECI fitting
    if args.make_substructures_only:
        print('Flag to create substructures only found.')
        clfit = ClusterInfo(clusters_fname=f'{structure}/clusters_fit.out',)
        print(
            f'Found {clfit.num_clusters} no. of clusters to fit. Creating double as many structures...')
        ref_list = open('references.in', 'w')
        ref_list.write(".\n")
        for label in range(clfit.num_clusters*args.mult_substructures):
            create_structure(f'ecifit_{label}', args.percent_shuffle)
            ref_list.write(f'ecifit_{label}\n')
        ref_list.close()

        sys.exit('Created substructures. Now exiting')
    # End of substructure making only.

    # This part of the code only fits the SRO correction vs T part.
    # This section is repeated at the very end because I didn't want to write another wrapper for 20 lines of code.
    if args.fit_sro_only:
        print('Flag to fit SRO as a function of T only found. Skipping all optimisation Steps.')
        best_params = sro_T_fit(sro_T,
                                args.degree,
                                args.out,
                                args.coeff_in,
                                args.skip_expo,
                                args.sro_method,
                                args.verbose
                                )

        with open(f'{args.coeff_out}', 'w') as fout:
            for d in range(args.degree+1):
                c = best_params[f'coeff_{d}']
                e = best_params[f'exp_{d}']
                fout.write(f'{c},{e}\n')
            bestC = best_params['C']
            fout.write(f'{bestC},0')
        sys.exit(1)
    # End of SRO correction fitting to T only


    # Generate Full Cluster Description
    try:
        _ = subprocess.run(['cvmclus', f'-m={phase}/{args.maximal_clusters}', f'-l={structure}/{args.lat}'],
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE,
                           check=True
                           )
    except subprocess.SubprocessError as suberr:
        print('Error in generating cluster configuration files for CVM...')
        print(suberr)
        print('Continuing to run. Might work if the required files already exists, maybe created by some previous run of cvmclus')

    print("Cluster Description for CVM:")
    clusters_full = ClusterInfo(clusters_fname=f'{structure}/{args.clusters}',
                                kb_fname=f'{structure}/{args.kb}',
                                clustermult_fname=f'{structure}/{args.clustermult}',
                                configmult_fname=f'{structure}/{args.configmult}',
                                config_fname=f'{structure}/{args.config}',
                                vmat_fname=f'{structure}/{args.vmat}',
                                eci_fname=f'{structure}/{args.eci}',
                                )

    # This section of the code either chooses to skip fitting ECIs
    # Or go ahead, read from substructures to do the ECI fit
    if args.skip_eci_fitting:
        print(f"Skipping ECI fitting step. Using {args.eci} instead")
        print(clusters_full.eci)
    else:
        print('\n===================================================\n')
        print(
            'Fitting ECIs.\n')
        energies = {}
        correlations = {}
        try:
            with open(f'{structure}/{args.reference_structures}', 'r') as fref:
                reference_structures = [
                    structure.rstrip() for structure in fref.readlines()]
        except FileNotFoundError as fnotf:
            print(fnotf)
            print(f"{args.reference_structures} not found. Exiting.\n")
            sys.exit(1)

        clusters_fit = ClusterInfo(
            args.clusters_fit, None, None, None, None, None,)

        for struc in reference_structures:
            try:
                with open(f'{struc}/energy', 'r') as energy_file:
                    e = float(energy_file.readline())

                num_atoms = sum(1 for line in open(f"{struc}/str.in")) - 6
                energies[struc] = e/num_atoms
                with open(f'{struc}/energy_atom', 'w') as feperatom:
                    feperatom.write(str(e/num_atoms))
                corr = subprocess.run(['corrdump', '-c', f'-cf={structure}/{args.clusters_fit}', f'-s={struc}/str.in', f'-l={structure}/{args.lat}'],
                                      stdout=subprocess.PIPE,
                                      stderr=subprocess.PIPE,
                                      check=True
                                      )
                # convert from bytes to string list
                corr = corr.stdout.decode('utf-8').split('\t')[:-1]
                corr = np.array(corr, dtype=np.float32)  # convert to arrays
                assert corr[0] == 1
                correlations[struc] = corr

                print(f"Found structure {struc.split('/')[-1]} with energy : {e/num_atoms}")
                print(f"Correlations {struc.split('/')[-1]} : {corr}\n")

            except FileNotFoundError as fnotf:
                print(fnotf)
                print(
                    f"Energy of reference structure {struc.split('/')[-1]} not found. Probably some error in DFT calc")
        
        if args.use_lsfit:
            eci_tmp = fit_eci_lsfit(
                clusters_fit, correlations, energies, structure)
        elif args.use_ransac:
            eci_tmp = fit_eci_ransac(clusters_fit,
                                     correlations,
                                     energies,
                                     structure
                                    )
        eci_tmp = np.array(
            [*eci_tmp, *np.zeros(clusters_full.num_clusters - clusters_fit.num_clusters)])
        for index, eci in clusters_full.eci.items():
            clusters_full.eci[index] = eci_tmp[index]

        print(f'Fitted ECIs : {clusters_full.eci}')
        print(f'Writing Fitted ECIs to file {args.eci}')
        with open(f'{args.eci}', 'w') as eci_file:
            eci_file.write(f'{clusters_full.num_clusters}\n')
            for _, eci in clusters_full.eci.items():
                eci_file.write(f'{eci}\n')

        print('\n========================================\n')

        for eci, cluster_idx in zip(eci_tmp, clusters_full.clusters.keys()):
            clusters_full.eci[cluster_idx] = eci

    if args.fit_eci_only:
        sys.exit('Flag to fit only detected. Exiting now...')
    # End ECI fitting

    results_sro = []
    with open(f'{structure}/energy_atom', 'r') as f:
        for line in f.readlines():
            F_sqs = float(line)
            print(f"Read in SQS energy\t: {F_sqs:.4f}")

    corr_rnd = subprocess.run(['corrdump', '-c', f'-cf={structure}/{args.clusters}', f'-s={structure}/str.in', f'-l={structure}/{args.lat}', '-rnd'],
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE,
                              check=True
                              )
    # convert from bytes to string list
    corr_rnd = corr_rnd.stdout.decode('utf-8').split('\t')[:-1]
    corr_rnd = np.array(corr_rnd, dtype=np.float32)  # convert to arrays
    assert corr_rnd[0] == 1
    assert clusters_full.check_result_validity(corr_rnd)
    np.savetxt('disordered_correlations.out',corr_rnd)

    FIXED_CORRS = corr_rnd[clusters_full.single_point_clusters]
    constraints = Constraints(clusters_full)
    bounds = CorrBounds(clusters_full.num_clusters, len(
        clusters_full.single_point_clusters))

    # This part of the code find the ordered correlation given the current ECI
    # Is skipped if no norm constraint if requried
    if not args.no_constraint:
        print("Norm Constraint activated...\n")

        options = {'disp': bool(args.verbose),
                   'maxiter': args.maxiter,
                   'tol': args.xtol,
                  }

        print('Calculating Ordered Correlation....')
        result_ord = opt.find_ordered(cluster_data=clusters_full,
                                      corr=corr_rnd,
                                      method=args.linprog_method,
                                      options=options,
                                     )
        corr_ord = result_ord.x
        print(f"Ordered correlation\t: {corr_ord}")
        ord2disord_dist = np.linalg.norm(corr_ord - corr_rnd)
        print(
            f"L2 norm between the fully disordered and ordered state:\t {ord2disord_dist}")
        print('\n========================================\n')
        if args.fit_ordered_only:
            sys.exit("Flag to find ordered state only detected. Exiting...")
        print('Starting T optimisation...\n')
    else:
        if args.fit_ordered_only:

            print("Flag to find ordered state only detected.")
            options = {'disp': bool(args.verbose),
                       'maxiter': args.maxiter,
                       'tol': args.xtol,
                      }

            print('Calculating Ordered Correlation....')
            result_ord = opt.find_ordered(cluster_data=clusters_full,
                                          corr=corr_rnd,
                                          method=args.linprog_method,
                                          options=options
                                         )
            corr_ord = result_ord.x
            print(f"Ordered correlation\t: {corr_ord}")
            sys.exit('Exiting...')

        print("Norm Constraint not activated.\n")
        print("Turning off SRO fit flag since constraint is not activated.\n")
        args.skip_sro_fit = True
        print('Starting T optimisation...\n')

    # End of the calcualting ordered correlations
    if args.approx_deriv:
        print('Approximating the derivatives - Jacobian : a 3-point finite diffrence scheme, Hessian : BFGS')
    else:
        print('Using Analytical gradients and hessian...')

    for T in custom_linspace(start=args.Tmin, stop=args.Tmax, step=args.Tstep):

        print(f'\nOptimising at temperature {T} K')

        F_rnd = F(corr_rnd,
                  clusters_full.vmat,
                  clusters_full.kb,
                  clusters_full.clusters,
                  clusters_full.clustermult,
                  clusters_full.configmult,
                  T,
                  clusters_full.eci)
        print(f"Disordered CVM energy @ T = {T}K\t: {F_rnd:.4f}")
        print(f"Disordered Correlations @ T = {T}K\t: {corr_rnd}")

        if not args.no_constraint:
            constraints_sro = constraints.get_constraints_sro(
                corr_ord, corr_rnd)
        else:
            constraints_sro = constraints.get_constraints_ordered(corr_rnd)

        bounds_sro = bounds.get_sro_bounds(FIXED_CORRS)

        options = {'verbose': args.verbose,
                   'maxiter': args.maxiter,
                   'xtol': args.xtol,
                   'gtol': args.gtol,
                   'initial_constr_penalty': 1
                   }

        result = opt.fit(F=F_efficient,
                         cluster_data=clusters_full,
                         temp=T,
                         options=options,
                         jac=F_jacobian_efficient,
                         hess=F_hessian_efficient,
                         NUM_TRIALS=args.global_trials,
                         bounds=bounds_sro,
                         constraints=constraints_sro,
                         corrs_trial=corr_rnd,
                         display_inter=True,
                         approx_deriv=args.approx_deriv,
                         init_random=False,
                         init_disordered=True,
                         seed=args.seed,
                         early_stopping_cond=args.earlystop
                         )
        F_cvm = result.fun
        print(f"Optimised CVM energy @ T = {T}K\t: {F_cvm:.4f}")
        print(f"Optimised Correlation @ T = {T}K\t: {result.x}")
        print("\n#################################################")
        F_solid_solution = F_sqs + F_cvm - F_rnd
        results_sro.append({'structure': structure.split('/')[-1],
                            'temperature': T,
                            'corrs': list(result.x),
                            'F_sqs': F_sqs,
                            'F_rnd': F_rnd,
                            'F_cvm': F_cvm
                            }
                           )

        corrcols = [f'corr {i}' for i in range(clusters_full.num_clusters)]
        for item in results_sro:
            for idx, corrnum in enumerate(corrcols):
                item[f'{corrnum}'] = item['corrs'][idx]

        with open(args.out, 'w') as fout:
            json.dump(results_sro, fout)

    print('Finished Optimising for SRO correction')

    # This section has the same code as above. But does the fit following a full optimisation
    if args.skip_sro_fit:
        print('Flag to skip SRO correction fitting as a function of T.')
    else:
        print('Fitting SRO corrections to a function of T')
        best_params = sro_T_fit(sro_T,
                                args.degree,
                                args.out,
                                args.coeff_in,
                                args.skip_expo,
                                args.sro_method,
                                args.verbose
                                )

        with open(f'{args.coeff_out}', 'w') as fout:
            for d in range(args.degree+1):
                c = best_params[f'coeff_{d}']
                e = best_params[f'exp_{d}']
                fout.write(f'{c},{e}\n')
            bestC = best_params['C']
            fout.write(f'{bestC},0')
