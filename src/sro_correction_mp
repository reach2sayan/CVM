#!/usr/bin/env python3
"""
Code Created By Sayan Samanta and Axel Van de Walle
"""

import argparse
import os
from pathlib import Path
import sys
import glob
import warnings
import json
import subprocess
import multiprocessing as mp
import numpy as np
import optimiser as opt
from constraints import Constraints
from bounds import CorrBounds
from energyfunctions import F, F_jacobian, F_hessian
from clusterdata import ClusterInfo
from logger import Logger

def custom_linspace(start,stop,step=1):
    """
    Like np.linspace but uses step instead of num
    This is inclusive to stop, so if start=1, stop=3, step=0.5
    Output is: array([1., 1.5, 2., 2.5, 3.])
    """
    return np.linspace(start, stop, int((stop - start) / step + 1))

def get_parsed_args():

    cwd = os.getcwd()
    parser = argparse.ArgumentParser(description='CVM SRO Error Correction Code')
    parser.add_argument('--ch',
                        action='store_true',
                        default=False,
                        help="performs a inflection-detection optimisation to estimate disordered state at low T (default: %(default)s)"
                       )
    parser.add_argument('--clusters_fit',
                        default='clusters_fit.out',
                        help="contain the cluster description for fitting the ECIs (default: %(default)s)",
                       )
    parser.add_argument('--maxclus',
                        default='maxclus.in',
                        help="contains maximal cluster description for the correction (default: %(default)s)"
                       )
    parser.add_argument('--l',
                        default='lat.in',
                        help="contains the lattice description of the phase (default: %(default)s)"
                       )
    parser.add_argument('--reference_file',
                        default='ref_structures.in',
                        help="contains the list of reference structures for the ECI fit (default: %(default)s). If not file of such name is found, then the end-members are chosen as reference."
                       )
    parser.add_argument('--Tmin',
                        default=0,
                        type=int,
                        help="Minimum T at which the SRO correction is to be made (default: %(default)s)"
                       )
    parser.add_argument('--Tmax',
                        default=5000,
                        type=int,
                        help="Maximum T at which the SRO correction is to be made (default: %(default)s)"
                       )
    parser.add_argument('--nTemp',
                        default=11,
                        type=int,
                        help="No. of temperature points in which the SRO correction is to be evaluated (default: %(default)s)"
                       )
    parser.add_argument('--verbose', '-v', action='count', default=0,
                        help="Indicate the verbosity of the fit (default: %(default)s)",
                       )
    parser.add_argument('--maxiter',
                        default=3000,
                        type=int,
                        help="Indicate maximum iterations for the local optimiser (default: %(default)s)",
                       )
    parser.add_argument('--np',
                        default=1,
                        type=int,
                        help="No. of processes over which the optimisation would be divided (default: 1)",
                       )
    parser.add_argument('--xtol',
                        default=1e-12,
                        type=float,
                        help="Indicate the acceptable difference between two iterations (default: %(default)s)",
                       )
    parser.add_argument('--gtol',
                        default=1e-12,
                        type=float,
                        help="Indicate the acceptable violation of constraints (default: %(default)s)",
                       )
    parser.add_argument('--global_trials',
                        default=20,
                        type=int,
                        help="Indicate the number of initial point iteration for global minima search (default: %(default)s)",
                       )
    parser.add_argument('--show_warning',
                        action='store_true',
                        default=False,
                        help="Enables to show warning (default: %(default)s)",
                       )
    parser.add_argument('--out',
                        default=f'{cwd}/latest_result.json',
                        help="Indicates the name of the output file (default: latest_result.json)",
                       )
    parser.add_argument('--toscreen',
                        action='store_true',
                        default=False,
                        help="Enable logging to screen (default: %(default)s)",
                       )
    parser.add_argument('--logfile',
                        default=f'{cwd}/log.out',
                        help="Filename for the log file (default: log.out)"
                       )

    return parser.parse_args()

def optimiser_wrapper(param_dict):

    vmat = param_dict['vmat']
    kb = param_dict['kb']
    clusters = param_dict['clusters']
    configs = param_dict['configs']
    configcoef = param_dict['configcoef']
    eci = param_dict['eci']
    temp = param_dict['T']
    options = param_dict['options']
    F = param_dict['F']
    jac = param_dict['jac']
    hess = param_dict['hess']
    NUM_TRIALS = param_dict['NUM_TRIALS']
    FIXED_CORR_1 = param_dict['FIXED_CORR_1']
    bounds = param_dict['bounds']
    constraints = param_dict['constraints']
    num_clusters = param_dict['num_clusters']
    corrs_trial= param_dict['corrs_trial']
    F_sqs = param_dict['F_sqs']
    F_rnd = param_dict['F_rnd']
    print(temp)

    result = opt.fit(F=F,
                     vmat=vmat, kb=kb,
                     clusters=clusters,
                     configs=configs,
                     configcoef=configcoef,
                     eci=eci,
                     temp=temp,
                     options=options,
                     jac=jac,
                     hess=hess,
                     NUM_TRIALS=NUM_TRIALS,
                     FIXED_CORR_1=FIXED_CORR_1,
                     FIXED_CORR_2=None,
                     bounds=bounds,
                     constraints=constraints,
                     num_clusters=num_clusters,
                     NN=False,
                     corrs_trial=corrs_trial
                    )

    F_cvm = result.fun
    #print(f"Optimised CVM energy\t: {F_cvm:.4f}")
    #print(f"Optimised Correlation\t: {result.x}")
    #    hessian = F_hessian(result.x,clusters_full.vmat,
    #                        clusters_full.kb,
    #                        clusters_full.clusters,
    #                        clusters_full.configs,
    #                        clusters_full.configcoef,
    #                        T,
    #                        clusters_full.eci
    #                       )
    #print(f"Hessian of CVM optimised {structure.split('/')[-1]} :\n {hessian}")
    #print(f"Eigen values of Optimised: {np.linalg.eigvals(hessian)}") 
    F_solid_solution = F_sqs + F_cvm - F_rnd
    results_sro = {'structure': structure.split('/')[-1],
                   'temperature': temp,
                   'corrs': list(result.x),
                   'F_sqs': F_sqs,
                   'F_rnd': F_rnd,
                   'F_cvm': F_cvm
                  }

    corrcols = [f'corr {i}' for i in range(num_clusters)]
    for idx, corrnum in enumerate(corrcols):
        results_sro[f'{corrnum}'] = results_sro['corrs'][idx]

    return results_sro

if __name__ == '__main__':

    np.set_printoptions(suppress=True, precision=4)

    args = get_parsed_args()
    #sys.stdout = Logger(sys.stdout, f'{args.logfile}_{T}', args.toscreen)
    if not args.show_warning:
        warnings.filterwarnings("ignore")
    if args.ch:
        print("Hessian is constrained to remain +ve definite")

    results_sro = []
    structure = os.getcwd()
    path = Path(structure)
    phase = str(path.parent.absolute())

    print('\n============================')
    print(f"Working on Structure: {structure.split('/')[-1]}")
    print()

    ref_structures = []
    try:
        with open(f'{structure}/{args.reference_file}','r') as ref_file:
            for line in ref_file.readlines():
                ref_structures.append(line)
    except FileNotFoundError:
        print(f"No reference structure ({args.reference_file}) file. Assuming endmembers as reference.")
        for f in glob.glob(f'{phase}/sqs_*'):
            if os.path.isfile(os.path.join(f,'endmem')):
                ref_structures.append(f)
    
    #Fit ECIs
    energy = {}
    corrs = {}
    for struc in [*ref_structures,structure]: 
        try:
            with open(f'{struc}/energy','r') as energy_file:
                e = float(energy_file.readline())
                energy[struc] = e
                corr = subprocess.run(['corrdump','-c', f'-cf={phase}/{args.clusters_fit}', f'-s={struc}/str.in', f'-l={phase}/{args.l}'],
                                      stdout=subprocess.PIPE,
                                      stderr=subprocess.PIPE,
                                      check=True
                                     )

                corr = corr.stdout.decode('utf-8').split('\t')[:-1] #convert from bytes to string list
                corr = np.array(corr, dtype=np.float32) #convert to arrays
                corrs[struc] = corr
        except FileNotFoundError:
            print('Energy File (probably of the reference structure) not found.')

    clusters_fit = ClusterInfo.read_clusters(f'{phase}/{args.clusters_fit}')
    NUM_CLUSTERS = len(clusters_fit)
    """
    We are doing Ax = b
    where A = mult_corr
    and B = energy_fits
    """

    mult = np.array([cluster['mult'] for cluster in clusters_fit.values()])
    only_corr = np.array([corr for _ , corr in corrs.items()])
    energy_fits = np.array([e for _, e in energy.items()])
    mult_corr = np.array([corr*mult for corr in only_corr])
    print("Fitting ECI's...")
    ecis_fitted = np.linalg.solve(mult_corr, energy_fits)
    print(f"ECI's : {ecis_fitted}") 

    #Make new ECI file
    TOT_ECI = len(ClusterInfo.read_clusters(f'{phase}/clusters.out'))
    ecis = np.array([*ecis_fitted, *([0]*(TOT_ECI - len(ecis_fitted)))])
    with open(f'{structure}/eci.out','w') as eci_file:
        eci_file.write(f'{TOT_ECI}\n')
        for eci in ecis:
            eci_file.write(f'{eci}\n')

    #Generate Full Cluster Description
    clusters_full = subprocess.run(['cvmclus', f'-m={phase}/{args.maxclus}', f'-l={phase}/{args.l}'],
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE,
                                   cwd=f'{phase}/',
                                   check=True
                                  )
    clusters_full = ClusterInfo(f'{phase}/clusters.out',
                        f'{phase}/kb.out',
                        f'{phase}/configcoef.out',
                        f'{phase}/config.out',
                        f'{phase}/vmat.out',
                        f'{structure}/eci.out',
                       )
    NUM_CLUSTERS = len(clusters_full.clusters)

    #Check if the fit is done properly
    full_corrs = {}
    for struc in [*ref_structures,structure]:
        corr = subprocess.run(['corrdump','-c', f'-cf={phase}/clusters.out', f'-s={struc}/str.in', f'-l={phase}/{args.l}'],
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE,
                              check=True
                             )
        corr = corr.stdout.decode('utf-8').split('\t')[:-1] #convert from bytes to string list
        corr = np.array(corr, dtype=np.float32) #convert to arrays
        full_corrs[structure] = corr

    for s, full_corr in full_corrs.items():
        test_E1 = F(full_corr,
                    clusters_full.vmat,
                    clusters_full.kb,
                    clusters_full.clusters,
                    clusters_full.configs,
                    clusters_full.configcoef,
                    0,
                    clusters_full.eci)

        with open(f'{s}/energy','r') as f:
            for line in f.readlines():
                test_E2 = float(line)
        assert np.isclose(test_E1, test_E2)

    with open(f'{structure}/energy','r') as f:
        for line in f.readlines():
            F_sqs = float(line)
            print(f"Read in SQS energy\t: {F_sqs:.4f}")

    #print(f'\nOptimising at temperature {T} K') 
    corr_rnd = subprocess.run(['corrdump','-c', f'-cf={phase}/clusters.out', f'-s={structure}/str.in', f'-l={phase}/{args.l}','-rnd'],
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE
                             )
    corr_rnd = corr_rnd.stdout.decode('utf-8').split('\t')[:-1] #convert from bytes to string list
    corr_rnd = np.array(corr_rnd, dtype=np.float32) #convert to arrays
    assert corr_rnd[0] == 1
    assert clusters_full.check_result_validity(corr_rnd)

    print(f"Disordered Correlations\t: {corr_rnd}")

    FIXED_CORR_1 = corr_rnd[1]

    bounds = CorrBounds(NUM_CLUSTERS)

    bounds_sro = bounds.get_pd_bounds(FIXED_CORR_1)

    options = {'verbose' : args.verbose,
               'maxiter' : args.maxiter,
               'xtol'    : args.xtol,
               'gtol'    : args.gtol,
               'initial_constr_penalty' : 10
              }
    param_dict = {}
    param_dict['vmat'] = clusters_full.vmat 
    param_dict['kb'] = clusters_full.kb
    param_dict['clusters'] = clusters_full.clusters
    param_dict['configs'] = clusters_full.configs
    param_dict['configcoef'] = clusters_full.configcoef
    param_dict['eci'] = clusters_full.eci
    param_dict['options'] = options
    param_dict['F'] = F
    param_dict['jac'] = F_jacobian
    param_dict['hess'] = F_hessian
    param_dict['NUM_TRIALS'] = args.global_trials
    param_dict['FIXED_CORR_1'] = FIXED_CORR_1
    param_dict['FIXED_CORR_2'] = None
    param_dict['bounds'] = bounds_sro
    param_dict['num_clusters'] = NUM_CLUSTERS
    param_dict['NN'] = False
    param_dict['corrs_trial'] = corr_rnd
    param_dict['F_sqs'] = F_sqs
    
    pool = mp.Pool(processes=mp.cpu_count())
    T = list(custom_linspace(start=args.Tmin,stop=args.Tmax, step=args.nTemp))
    param_list = []
    for temp in T:
        param_dict_temp = param_dict.copy()
        constraints = Constraints(clusters_full.vmat,
                                  clusters_full.kb,
                                  clusters_full.clusters,
                                  clusters_full.configs,
                                  clusters_full.configcoef,
                                  temp,
                                  clusters_full.eci
                                 )
        constraints_sro = constraints.get_constraints_sro(FIXED_CORR_1,args.ch)
        param_dict_temp['constraints'] = constraints_sro
        F_rnd = F(corr_rnd,
                  clusters_full.vmat,
                  clusters_full.kb,
                  clusters_full.clusters,
                  clusters_full.configs,
                  clusters_full.configcoef,
                  temp,
                  clusters_full.eci)
        param_dict_temp['F_rnd'] = F_rnd
        print(f"Disordered CVM energy\t @ T = {temp} : {F_rnd:.4f}")
        param_dict_temp['T'] = temp
        param_list.append(param_dict_temp)

    import time
    startTime = time.time()
    
    if args.np == -1:
        processes = mp.cpu_count()
    else:
        processes = args.np

    with mp.Pool(processes=processes) as pool:
        result = pool.map(optimiser_wrapper,param_list)
    with open(f'{args.out}','w') as fout:
        json.dump(result, fout)
    
    executionTime = (time.time() - startTime)
    print('Execution time in seconds: ' + str(executionTime))

