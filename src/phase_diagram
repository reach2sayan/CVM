#!/usr/bin/env python3

import argparse
import dataloader as dl
from energyfunctions import F, F_jacobian, F_hessian
import numpy as np
from ase.units import kB
import optimiser as opt
import pandas as pd
from constraints import Constraints
from bounds import CorrBounds
import warnings
import random
from logger import Logger
import sys
import pprint
import os


if __name__ == '__main__':

    cwd = os.getcwd()
    datadir = f'{cwd}/data'
    outdir = f'{cwd}/results'
    np.set_printoptions(suppress=True,precision=2)
    random.seed(42)
    np.random.seed(seed=42)    

    parser = argparse.ArgumentParser()
    parser.add_argument('--eci',
                        default=f'{datadir}/eci.out', 
                        help="file containing ECI's (default: %(default)s)",
                       )
    parser.add_argument('--vmat', 
                        default=f'{datadir}/vmat.out',
                        help="file containing the vmatrix (default: %(default)s)",
                       )
    parser.add_argument('--clusters',
                        default=f'{datadir}/clusters.out',
                        help="file contain the maximal cluster description (default: %(default)s)",
                       )
    parser.add_argument('--kb',
                        default=f'{datadir}/kb.out',
                        help="file containing the kikuchi-barker coefficients (default: %(default)s)",
                       )
    parser.add_argument('--configcoef',
                        default=f'{datadir}/configcoef.out',
                        help="file containing coefficient for each subcluster (default: %(default)s)",
                       )
    parser.add_argument('--configs','--config',
                        default=f'{datadir}/config.out',
                        help="file containing subcluster descriptions (default: %(default)s)",
                       )
    parser.add_argument('--Tmin',
                        type=float,
                        default=0,
                        help="minimum T for phase diagram (default: %(default)s)",
                       )
    parser.add_argument('--Tmax',
                        type=float,
                        default=500.0,
                        help="maximum T for phase diagram (default: %(default)s)",
                       )
    parser.add_argument('--nTemp',
                        type=int,
                        default=11,
                        help="Number of data points between Tmin and Tmax (default: %(default)s)",
                       )
    parser.add_argument('--Xmin',
                        type=float,
                        default=None,
                        help="minimum 1-point correlations (default: -1)",
                       )
    parser.add_argument('--Xmax',
                        type=float,
                        default=None,
                        help="maximum 1-point correlations (default: +1)",
                       )
    parser.add_argument('--ncorr',
                        type=int,
                        default=9,
                        help="Number of data points between Xmin and Xmax (default: %(default)s)",
                       )
    parser.add_argument('--out',
                        default=f'{outdir}/phasediagram_latest.csv',
                        help="Name of the dataframe containing the result of the optimisation"
                       )
    parser.add_argument('--verbose', '-v', action='count', default=0,
                        help="Indicate the verbosity of the fit (default: %(default)s)",
                       )
    parser.add_argument('--maxiter',
                        default=3000,
                        type=int,
                        help="Indicate maximum iterations for the local optimiser (default: %(default)s)",
                       )
    parser.add_argument('--xtol',
                        default=1e-12,
                        type=float,
                        help="Indicate the acceptable difference between two iterations (default: %(default)s)",
                       )
    parser.add_argument('--gtol',
                        default=1e-12,
                        type=float,
                        help="Indicate the acceptable violation of constraints (default: %(default)s)",
                       )
    parser.add_argument('--global_trials',
                        default=100,
                        type=int,
                        help="Indicate the number of initial point iteration for global minima search (default: %(default)s)",
                       )
    parser.add_argument('--uniform',
                        action='store_true',
                        default=True,
                        help="Use uniform sampling to search global minima (default: %(default)s)",
                       )
    parser.add_argument('--basinhopping',
                        action='store_true',
                        default=False,
                        help="Use basin hopping to search global minima",
                       )
    parser.add_argument('--show_warning',
                        action='store_true',
                        default=False,
                        help="Enables to show warning",
                       )
    parser.add_argument('--toscreen',
                        action='store_true',
                        default=False,
                        help="Enable logging to screen",
                       )
    parser.add_argument('--logfile',
                        default=f'{cwd}/log.out',
                        help="Filename for the log file (default: %(default)s)"
                       )

    args = parser.parse_args()

    if not args.show_warning:
        warnings.filterwarnings("ignore")

    sys.stdout = Logger(sys.stdout, args.logfile,args.toscreen)
    clusters = dl.read_clusters(args.clusters)
    kb = dl.read_kbcoeffs(args.kb)
    configcoef = dl.read_configcoef(args.configcoef)
    configs = dl.read_configs(args.configs)
    vmat = dl.read_vmatrix(args.vmat)
    eci = dl.read_eci(args.eci)
    outfile = args.out
    MIN_TEMP = args.Tmin
    MAX_TEMP = args.Tmax
    if args.Xmin is None:
        MIN_CORR = -1+np.finfo(float).eps
    else:
        MIN_CORR = args.Xmin
    if args.Xmax is None:
        MAX_CORR = 1-np.finfo(float).eps
    else:
        MAX_CORR = args.Xmax
    steps = args.nTemp
    corr_steps = args.ncorr
    NUM_TRIALS = args.global_trials
    num_clusters = len(clusters)   

    results_phasediagram = pd.DataFrame(columns = ['T', '1-point_corr', 'F','corrs'])

    constraints = Constraints(clusters, configcoef, vmat)
    bounds = CorrBounds(num_clusters)

    options = {'verbose' : args.verbose,
               'maxiter' : args.maxiter,
               'xtol'    : args.xtol,
               'gtol'    : args.gtol,
               'initial_constr_penalty' : 10
              }

    print("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")
    print("Parameters: ")
    print("ECI:")
    pprint.pp(eci)
    print("Vmatrix")
    pprint.pp(vmat)
    print("Clusters:")
    pprint.pp(clusters)
    print("Cluster Coefficients:")
    pprint.pp(configcoef)
    print("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n")

    for temp in np.linspace(MIN_TEMP, MAX_TEMP, num=steps):
        for FIXED_CORR_1 in np.linspace(MIN_CORR, MAX_CORR, num=corr_steps):

            print('-----------------------------------------')
            print(f"## T: {temp} -- CORR_1: {FIXED_CORR_1}")
            print('-----------------------------------------')

            constraints_pd = constraints.get_constraints_phasediagram(FIXED_CORR_1)
            bounds_pd = bounds.get_pd_bounds(FIXED_CORR_1)

            result = opt.fit(F=F,
                             vmat=vmat, kb=kb, 
                             clusters=clusters, 
                             configs=configs, 
                             configcoef=configcoef,
                             temp=temp, 
                             eci=eci, 
                             options=options,
                             jac=F_jacobian,
                             hess=F_hessian,
                             NUM_TRIALS=NUM_TRIALS,
                             FIXED_CORR_1=FIXED_CORR_1,
                             FIXED_CORR_2=None,
                             bounds=bounds_pd,
                             constraints=constraints_pd,
                             num_clusters=num_clusters,
                             NN=False
                            )

            print(f"## Corrs: {result.x} -- ENERGY: {result.fun}")
            for cluster_idx, _ in clusters.items():
                print(np.matmul(vmat[cluster_idx],result.x))
            try:
                for cluster_idx in clusters.keys():
                    assert np.isclose(np.inner(configcoef[cluster_idx], np.matmul(vmat[cluster_idx], results.x)), 1.0)
            except AssertionError:
                print("Failed to find solution...Current Rho")
                for cluster_idx, _ in clusters.items():
                    print(np.matmul(vmat[cluster_idx],results.x))
                    continue

            results_phasediagram = results_phasediagram.append({'T' : temp, 
                                                               '1-point_corr' : FIXED_CORR_1, 
                                                               'F' : result.fun, 
                                                               'corrs': result.x,
                                                               }, 
                                                               ignore_index = True
                                                              )

    corrcols = [f'corr {i}' for i in range(num_clusters)]
    results_phasediagram[corrcols] = pd.DataFrame(results_phasediagram.corrs.tolist(), 
                                                  index = results_phasediagram.index,
                                                 )
    results_phasediagram.drop(['corrs'],axis=1,inplace=True)

    results_phasediagram.to_csv(outfile,index=False)
    
    #TODO: Add handler for plotting phase diagram
    #plot_tool.plot_phasediagram(results_phasediagram)






#corrs1 = np.array([1., 1., 1., 1., 1., 1.]) #Pure B
#corrs0 = np.array([1., -1., 1., 1., -1., 1.]) #Pure A
#corrssqs = np.array([1.    , 0.0   , 0.25,0.25  , 0.125 , 0.0625]) # AB - sqs
#corrsrand = np.array([1.   , *np.random.uniform(-1, 1, 5)]) 
#T = 1/kB
#
#f0 = F(corrs0, vmat, kb, clusters, configs, configcoef,T,eci)
#f1 = F(corrs1, vmat, kb, clusters, configs, configcoef,T,eci)
#fsqs = F(corrssqs, vmat, kb, clusters, configs, configcoef,T,eci)
#frand = F(corrsrand, vmat, kb, clusters, configs, configcoef,T,eci)
#print(f"Corrs 0: {f0:.2f} -- Corrs 1: {f1:.2f} -- Corrs Rand: {frand:.2f} -- Corrs SQS: {fsqs:.2f}")
#
#f_jaco0 = F_jacobian(corrs0, vmat, kb, clusters, configs, configcoef,T,eci)
#f_jaco1 = F_jacobian(corrs1, vmat, kb, clusters, configs, configcoef,T,eci)
#f_jacosqs = F_jacobian(corrssqs, vmat, kb, clusters, configs, configcoef,T,eci)
#f_jacorand = F_jacobian(corrsrand, vmat, kb, clusters, configs, configcoef,T,eci)
#print(f"Corrs 0: {f_jaco0} \nCorrs 1: {f_jaco1} \nCorrs Rand {f_jacorand} \nCorrs SQS {f_jacosqs}")
#
#f_hess0 = F_hessian(corrs0, vmat, kb, clusters, configs, configcoef,T,eci)
#f_hess1 = F_hessian(corrs1, vmat, kb, clusters, configs, configcoef,T,eci)
#f_hessrand = F_hessian(corrsrand, vmat, kb, clusters, configs, configcoef,T,eci)
#f_hesssqs = F_hessian(corrssqs, vmat, kb, clusters, configs, configcoef,T,eci)
#print(f"Corrs 0:\n {f_hess0} \n Corrs 1:\n {f_hess1}\n Corrs Rand:\n {f_hessrand} \n Corrs SQS:\n {f_hesssqs}")


