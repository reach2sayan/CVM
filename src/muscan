#!/usr/bin/env python3

import argparse
from energyfunctions import F_mu as F
from energyfunctions import F_jacobian_mu as F_jacobian
from energyfunctions import F_hessian_mu as F_hessian
from clusterdata import ClusterInfo
import numpy as np
import optimiser as opt
from constraints import Constraints
from bounds import CorrBounds
import warnings
import random
from logger import Logger
import sys
import os
import json


if __name__ == '__main__':

    cwd = os.getcwd()
    datadir = f'{cwd}/data'
    outdir = f'{cwd}/results'
    np.set_printoptions(suppress=True,precision=2)
    random.seed(42)
    np.random.seed(seed=42)    

    parser = argparse.ArgumentParser()
    parser.add_argument('--eci',
                        default=f'{datadir}/eci.out', 
                        help="file containing ECI's (default: %(default)s)",
                       )
    parser.add_argument('--vmat', 
                        default=f'{datadir}/vmat.out',
                        help="file containing the vmatrix (default: %(default)s)",
                       )
    parser.add_argument('--clusters',
                        default=f'{datadir}/clusters.out',
                        help="file contain the maximal cluster description (default: %(default)s)",
                       )
    parser.add_argument('--kb',
                        default=f'{datadir}/kb.out',
                        help="file containing the kikuchi-barker coefficients (default: %(default)s)",
                       )
    parser.add_argument('--configcoef',
                        default=f'{datadir}/configcoef.out',
                        help="file containing coefficient for each subcluster (default: %(default)s)",
                       )
    parser.add_argument('--configs','--config',
                        default=f'{datadir}/config.out',
                        help="file containing subcluster descriptions (default: %(default)s)",
                       )
    parser.add_argument('--Tmin',
                        type=float,
                        default=0,
                        help="minimum T for phase diagram (default: %(default)s)",
                       )
    parser.add_argument('--Tmax',
                        type=float,
                        default=500.0,
                        help="maximum T for phase diagram (default: %(default)s)",
                       )
    parser.add_argument('--nTemp',
                        type=int,
                        default=11,
                        help="Number of data points between Tmin and Tmax (default: %(default)s)",
                       )
    parser.add_argument('--Mumin',
                        type=float,
                        default = -0.25,
                        help="minimum 1-point correlations (default: -0.25)",
                       )
    parser.add_argument('--Mumax',
                        type=float,
                        default = 0.25,
                        help="maximum 1-point correlations (default: +0.25)",
                       )
    parser.add_argument('--nmu',
                        type=int,
                        default=9,
                        help="Number of data points between Xmin and Xmax (default: %(default)s)",
                       )
    parser.add_argument('--out',
                        default=f'{outdir}/muscan_latest.csv',
                        help="Name of the dataframe containing the result of the optimisation (default: %(default)s)"
                       )
    parser.add_argument('--verbose', '-v', action='count', default=0,
                        help="Indicate the verbosity of the fit (default: %(default)s)",
                       )
    parser.add_argument('--maxiter',
                        default=3000,
                        type=int,
                        help="Indicate maximum iterations for the local optimiser (default: %(default)s)",
                       )
    parser.add_argument('--xtol',
                        default=1e-12,
                        type=float,
                        help="Indicate the acceptable difference between two iterations (default: %(default)s)",
                       )
    parser.add_argument('--gtol',
                        default=1e-12,
                        type=float,
                        help="Indicate the acceptable violation of constraints (default: %(default)s)",
                       )
    parser.add_argument('--global_trials',
                        default=100,
                        type=int,
                        help="Indicate the number of initial point iteration for global minima search (default: %(default)s)",
                       )
    parser.add_argument('--uniform',
                        action='store_true',
                        default=True,
                        help="Use uniform sampling to search global minima (default: %(default)s)",
                       )
    parser.add_argument('--basinhopping',
                        action='store_true',
                        default=False,
                        help="Use basin hopping to search global minima",
                       )
    parser.add_argument('--show_warning',
                        action='store_true',
                        default=False,
                        help="Enables to show warning (default: %(default)s)",
                       )
    parser.add_argument('--toscreen',
                        action='store_true',
                        default=False,
                        help="Enable logging to screen (default: %(default)s)",
                       )
    parser.add_argument('--logfile',
                        default=f'{cwd}/log.out',
                        help="Filename for the log file (default: %(default)s)"
                       )

    args = parser.parse_args()

    if not args.show_warning:
        warnings.filterwarnings("ignore")

    sys.stdout = Logger(sys.stdout, args.logfile,args.toscreen)

    clusters = ClusterInfo(args.clusters,
                           args.kb,
                           args.configcoef,
                           args.configs,
                           args.vmat,
                           args.eci,
                          )

    outfile = args.out
    MIN_TEMP = args.Tmin
    MAX_TEMP = args.Tmax
    MIN_MU = args.Mumin
    MAX_MU = args.Mumax
    steps = args.nTemp
    mu_steps = args.nmu
    NUM_TRIALS = args.global_trials
    num_clusters = len(clusters.clusters)   

    results_muscan = []

    constraints = Constraints(clusters.clusters, 
                              clusters.configcoef, 
                              clusters.vmat)

    bounds = CorrBounds(num_clusters)

    options = {'verbose' : args.verbose,
               'maxiter' : args.maxiter,
               'xtol'    : args.xtol,
               'gtol'    : args.gtol,
               'initial_constr_penalty' : 10
              }


    print("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")
    print("Cluster Parameters: ")
    print(clusters)
    print("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n")

    for temp in np.linspace(MIN_TEMP, MAX_TEMP, num=steps):
        for MU in np.linspace(MIN_MU, MAX_MU, num=mu_steps):

            mu = np.array([-MU/2,+MU/2])
            print('-----------------------------------------')
            print(f"## T: {temp} -- CORR_1: {mu}")
            print('-----------------------------------------')

            constraints_muscan = constraints.get_constraints_muscan()
            bounds_muscan = bounds.get_muscan_bounds()

            result = opt.mufit(F=F,
                               vmat=clusters.vmat, kb=clusters.kb, 
                               clusters=clusters.clusters, 
                               configs=clusters.configs, 
                               configcoef=clusters.configcoef,
                               eci=clusters.eci, 
                               temp=temp, 
                               options=options,
                               jac=F_jacobian,
                               hess=F_hessian,
                               NUM_TRIALS=NUM_TRIALS,
                               bounds=bounds_muscan,
                               constraints=constraints_muscan,
                               num_clusters=num_clusters,
                               mu=mu
                            )

            print(f"## Corrs: {result.x} -- ENERGY: {result.fun}")
            print(f"## Rho:")
            print(f"{clusters.rho(result.x)}")

            clusters.check_result_validity(result.x)

            results_muscan.append({'T' : temp, 
                                   'Mu' : MU, 
                                   'F' : result.fun, 
                                   'corrs': list(result.x),
                                  }, 
                                 )

            corrcols = [f'corr {i}' for i in range(num_clusters)]
            for item in results_muscan:
                for idx, corrnum in enumerate(corrcols):
                    item[f'{corrnum}'] = item['corrs'][idx]
            with open(outfile,'w') as fout:
                json.dump(results_muscan, fout)
